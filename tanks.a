;; -*- asm -*-

;; Border Control Memory 53280
;; Background Control Memory 53281

!source "macros.a"
!source "sprites.a"

!zone BASIC {
	* = $1c01

	!wo  .EndOfText             ; Pointer to end of text
    !wo  $000a                  ; Line number 10
    !pet $9e, "4864", $00       ; SYS4864\0
    !by  $00, $00               ; End of Text Token
.EndOfText:
}

!addr {
!zone ZeroPage {
}

!zone SystemVarsAndRegisters {
	IRQHandlerPtr   = $0314
    IRQHandlerPtrHi = $0315

	CustomChars   = $2000
	Character_ROM = $d000

    SpritePtrStart   = $07f8
	SpriteColorStart = $d027
    SpritePosStart   = $d000
	SpriteXMSB       = $d010

	Joystick2     = $dc00
    Joystick1     = $dc01

	TextStart     = $0400
	SpriteEn      = $d015
	BgColor       = $D021
	BorderColor   = $D020

    MMU_Control   = $ff00

    VIC_Raster      = $d012
	VIC_Interrupt   = $d019
	VIC_SpSpCollide = $d01e
}
}

!zone Init {
	* = $1300

!macro .InitSprite .spriteno, .shapePtr, .facing, .color, .x, .y {
	;; Set sprite shape
    lda #.shapePtr / 64
    sta SpritePtrStart + .spriteno

    ;; Set sprite color
	lda #.color
	sta SpriteColorStart + .spriteno

	;; Set sprite position -- stride is 2, hence the multiply
	ldx #.x
    stx ShadowSpritePos + (.spriteno * 2)
    ldy #.y
    sty ShadowSpritePos + (.spriteno * 2) + 1

	;; Set facing direction
    lda #.facing
    sta SpriteFacing + .spriteno
}

Init:
	cld

    ;; Disable BASIC IRQs
    lda #$ff
	sta $d8
    sta $12fd

	;; Disable BASIC, leave I/O, Kernal, and Character ROMs
	lda #$00
    sta MMU_Control

	jsr ClearTextScreen
	jsr FadeToBlack
    jsr WedgeInterruptRoutine

	+.InitSprite 0, TankDown, DirDown, Color_Red,    0, 0
	+.InitSprite 1, TankUp,   DirUp,   Color_LtBlue, 148, 179
!for i, 2, 7 {
	+.InitSprite i, Bullet,   0,       Color_Black,  0, (i - 2) * 10
}

	;; Enable all sprites by default
    lda #$ff
	sta SpriteEn

    jmp GameLoop
}

!zone GameLoop {
GameLoop:
	;; Ensure we only process input update during vblank, once per frame
    bit FrameStartFlag
    bpl GameLoop

	;; Clear the frame start flag
	lda #$00
	sta FrameStartFlag

	;; Set the border color based upon collision
	lda CollisionFlag
    tax
	
    bne .borderRed
.borderBlack:
    lda #Color_Black
	jmp .next
.borderRed:
	lda #Color_LtRed
.next:
    sta BorderColor
	
	;; Clear the collision flag
	lda #$00
    sta CollisionFlag

	ldx #$00
	jsr HandleInput
	inx
	jsr HandleInput

	;; jsr UpdateBullets

    jmp GameLoop
}

!zone HandleInput {
HandleInput:
	;; Update tank position based upon Joystick
	sei
    lda #$ff
	sta $dc00
    sta $d02f
	lda Joystick2, x
	cli
	
	lsr
    bcc .ckup
    lsr
    bcc .ckdown
    lsr
    bcc .ckleft
    lsr
    bcc .ckright
    lsr
    bcc .ckfire
    rts

.ckleft:
!zn {
	lda ShadowSpritePos, x
	cmp #0
	beq +
    dec ShadowSpritePos, x
	
+   lda #TankLeft / 64
    sta SpritePtrStart, x
	lda #DirLeft
    sta SpriteFacing, x
    rts
}

.ckup:
!zn {
    lda ShadowSpritePos + 1, x
	cmp #0
    beq +
    dec ShadowSpritePos + 1, x

+   lda #TankUp / 64
    sta SpritePtrStart, x
	lda #DirUp
    sta SpriteFacing, x
    rts
}

.ckright:
!zn {
	lda ShadowSpritePos, x
	cmp #MaxXCoord
	beq +
    inc ShadowSpritePos, x
	
+   lda #TankRight / 64
    sta SpritePtrStart, x
	lda #DirRight
    sta SpriteFacing, x
    rts
}

.ckdown:
!zn {
    lda ShadowSpritePos + 1, x
	cmp #MaxYCoord
    beq +
	inc ShadowSpritePos + 1, x
	
+   lda #TankDown / 64
    sta SpritePtrStart, x
	lda #DirDown
    sta SpriteFacing, x
    rts
}

.ckfire:
	;; Spawn bullet if possible
    rts
}

!zone Globals {
;;; System IRQ pointer
SysISRPtr:     !by $00
SysISRPtrHi:   !by $00

;;; Tracks the direction the sprite last moved in. Zero means it is dead.
SpriteFacing:    !fill 8,  $00

;;; Shadow X/Y positions for sprites -- 255 max positions horizontally.
ShadowSpritePos: !fill 16, $00
ShadowSpritePosEnd:
	
FrameStartFlag:  !by $00
FrameStartRasterLine = 250
	
CollisionFlag:   !by $00

;;; Direction flags
DirUp           = %.......1
DirDown         = %......1.
DirLeft         = %.....1..
DirRight        = %....1...

;;; Constant; max bullet speed is 4px / frame
BulletSpeed = 4

;;; Max visible coordinates
MaxXCoord = 148
MaxYCoord = 179

VIC_Int_Scanline    = %.......#
VIC_Int_SpFgCollide = %......#.
VIC_Int_SpSpCollide = %.....#..
}

!zone InterruptCallback {
InterruptCallback:
	;; Ack the interrupts from the VIC
	lda VIC_Interrupt
	jsr MaybeTriggerFrame
	jsr CheckCollision

	;; Handle other functions not tightly coupled with the IRQs
	jsr UpdateSpritePositions
	jsr CycleBulletColors

	;; Give control back to the system ISR
	jmp (SysISRPtr)
}
	
!zone CheckCollision {
CheckCollision:
	;; Save A, since we'll use it in other triggers
    pha
	
	;; Check if we were triggered because of a sprite collision
	and #VIC_Int_SpSpCollide
	beq .out

	;; Clear out the collision register
	lda VIC_SpSpCollide

	;; Set the collision flag
	sta CollisionFlag

.out:
    pla
    rts
}

!zone MaybeTriggerFrame {
MaybeTriggerFrame:
	;; Save A, since we'll use it in other triggers
	pha

	;; Check if we were triggered by the raster trigger
	and #VIC_Int_Scanline
	beq .out

	;; Set the frame start flag
	lda #$ff
    sta FrameStartFlag

	;; Re-set the raster trigger
    lda #FrameStartRasterLine
    sta VIC_Raster

.out:
    pla
    rts
}

!zone CycleBulletColors {
CycleBulletColors:
    ;; Eight sprites
	ldx #$08

.loop:
	inc SpriteColorStart, x
    dex

	;; Skip the first two sprites
	cpx #$01
    bne .loop

    rts
}

;;; Updates the positions of the sprites using the shadow sprite data.
;;;
;;; Uses Shallan's technique of using the MSB of the X coordinate byte as the
;;; MSB for the VIC's Sprite MSB register. The visible playfield ends up being
;;; 148x179. 0,0 is correctly placed in the upper right of the playfield, and
;;; 148x179 is the last coordinate where all pixels of a sprite are visible.
;;;
;;; max-x: 148, max-y=179
;;;
!zone UpdateSpritePositions {
UpdateSpritePositions:
	;; ;; Prep stack for MSB bits
	lda #$00
	pha

    ;; Start from 255 (-1) since we increment first in the loop
    ldx #$ff

.updateNextSprite:
	;; Update X first
    inx
    lda ShadowSpritePos, x
	clc
    adc #24 / 2                 ; playfield starts at X=24
	asl                         ; shift MSB to carry
    sta SpritePosStart, x

	;; Store MSB in the stack for later
    pla
    ror
    pha

	;; Update Y next
    inx
	lda ShadowSpritePos, x
	clc
    adc #50                     ; playfield starts at Y=50
    sta SpritePosStart, x

	;; On to the next pair
	cpx #$0f                    ; 16 bytes to update
    bne .updateNextSprite

	;; Update the MSB
	pla
    sta SpriteXMSB

    rts
}

!zone WedgeInterruptRoutine {
WedgeInterruptRoutine:
	sei

	;; Save system ISR
    lda IRQHandlerPtr
    sta SysISRPtr
    lda IRQHandlerPtrHi
    sta SysISRPtrHi

	;; Install our ISR
    lda #<InterruptCallback
    sta IRQHandlerPtr
    lda #>InterruptCallback
    sta IRQHandlerPtrHi

	;; Set the raster trigger for triggering each frame
    lda #FrameStartRasterLine
    sta VIC_Raster

	cli
    rts
}

!zone FadeToBlack {
.border: !by 15, 12, 11, 0
.backgd: !by 13, 15, 11,  0

FadeToBlack:
    ldx #$00
.loop:
    lda .border, x
    sta BgColor
    lda .backgd, x
    sta BorderColor
	beq +

	ldy #100
    jsr BusyDelay
	inx

	jmp .loop
+

    rts
}

!zone ClearTextScreen {
ClearTextScreen:
    ldx #$00

!macro .SetToMaxChar .address {
	lda .address, x
    cmp #$20
    beq +

    lda #127
    sta .address, x
+
}

.loop:
	+.SetToMaxChar TextStart
    +.SetToMaxChar TextStart + $100
    +.SetToMaxChar TextStart + $200
    +.SetToMaxChar TextStart + $300
    inx
	bne .loop

!macro .DecToZero .address {
    lda .address, x
    cmp #$20
    beq +
    dec .address, x
+
}

	ldy #128
.dec_loop:
	+.DecToZero TextStart
	+.DecToZero TextStart + $100
	+.DecToZero TextStart + $200
	+.DecToZero TextStart + $300
    inx
    bne .dec_loop
    dey
    bne .dec_loop
    rts
}

;;; BusyDelay
;;; Y - number of times to wait
!zone BusyDelay {
BusyDelay:
	+SaveRegisters
    ldx #$00

.loop:
    inx
    bne .loop
    dey
    bne .loop

	+RestoreRegisters

    rts
}
